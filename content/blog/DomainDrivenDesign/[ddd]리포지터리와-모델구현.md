---
title: "[ddd]리포지터리와 모델구현"
date: 2020-03-06 18:01:57
category: domaindrivendesign
draft: false
---

## JPA를 이용한 리포지터리 구현
데이터 보관소로 RDBMS를 사용할 때 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 `ORM` 만한 것이 없다.

### 모듈 위치
리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.
> 리포지터리 구현 클래스를 인터페이스와 같은 패키지에 위치시키는 것은 좋은 방법이 아니다. => 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 *의존을 낮춰야 한다.*

### 리포지터리 기본 기능 구현
- 아이디로 애그리거트 조회하기
- 애그리거트 저장하기

```java
public interface OrderRepository {
    public Order findById(OrderNo no);
    public void save(Order order);
}
```
- 인터페이스는 애그리거트 루트를 기준으로 작성한다.
- 애그리거트를 조회 기능의 이름을 지을 때는 보통 `findBy 프로피터값`의 형식을 사용한다.
  - e.g. findById, findByOrdererId
  - findById()는 해당 애그리거트가 존재하지 않으면 null을 리턴한다. null을 사용하고 싶지 않다면 `Optional`을 이용해서 값을 리턴해도 된다.
- save() 메서드는 전달받은 애그리거트를 저장한다. 이를 구현한 클래스는 `JPA의 EntityManager`를 이용해서 기능 구현을 한다.
  - @PersistenceContext
  > 엔티티를 저장( persist() ) , 조회( find() 또는 JPQL , QueryDSL )하면 엔티티 매니저는 그 엔티티를 영속성 컨테스트에 보관하고 관리한다.
- 애그리거트를 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요 없다. JPA를 사용하면 트랙잭션 범위에서 변경한 데이터를 자동으로 DB에 반경해준다.
- 삭제 기능을 구현하는 메서드는 삭제할 애그리거트 객체를 파라미터로 전달받는다.
  - soft delete를 사용하는 편이 좋다.

## 매핑 구현

## 애그리거트 로딩 전략
- `즉시로딩`은 애그리거트 루트를 로딩하면 루트에 속한 모든 객체가 완전한 상태가 된다. 하지만, 애그리거트가 크면 즉시로딩 성능이 나빠진다. (p.136)
- `지연 로딩`은 동작 방식이 항상 동일하기 때문에 즉시 로딩처럼 경우의 수를 따질 필요가 없는 장점이 있다. 물론 지연 로딩은 즉시 로딩보다 쿼리 실행 횟수가 많아질 가능성이 더 높다.
- **애그리거트는 개념적으로 하나여야 한다. 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.**
  - 애그리거트는 개념적으로 완전해야하는 이유 중 하나는 표현영역에서 애그리거트이 상태를 보여줄 때 필요하기 때문인데 이건 별도의 조회 전용 기능을 구현하는 방식으로 하는게 유리할 때가 많다. => 따라서, 로딩 문제는 상태 변경과 더 관련이 있음.
  - 상태 변경 기능을 위해 완전해야 할 수 도 있지만, 트랜잭션 범위내에서 지연로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.
  - 또한, 보통 상태 변경보다 조회가 많으므로 상태 변경을 위해 지연 로딩 사용한다고 발생하는 추가 쿼리는 속도 저하에 문제가 되지 않는다.
그렇기에 애그리거트 모든 연관을 즉시 로딩할 필요는 없다.


## 애그리거트의 영속성 전파
애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할때도 하나로 처리해야 함을 의미한다. **즉, 저장과 삭제일때 모든 객체를 처리하는 메서드를 가져야한다.**
 - 저장 메서드는 애그리거트 루트만 저장하면 아노디고 애그리거트에 속한 모든 객체를 저장해야 한다.
 - 삭제 메서드는 애그리거트 루트뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.

- @Embeddable 타입은 자동으로 저장/삭제 되지만
- @Entity는 casecade={CascadeType.PERSIST, CascadeType.REMOVE} 해줘야 함게 저장/삭제 됨.

```java
@OneToMany(caseade = {ascadeType.PERSIST, CascadeType.REMOVE}, orphanRemoval = true)
@JoinColumn(name = "product_id")
@OrderColumn(name = "list_idx")
private List<Image> images = new ArrayList<>();
```

## 식별자 생성 기능
- 사용자가 직접 생성
  - 이메일 주소처럼 사용자가 직접 식별자를 입력
- 도메인 로직으로 생성
  - 식별자 생성규칙이 있는경우 엔티티를 생성할 때 이미 생성한 식별자를 전달하므로 엔티티가 식별자 생성기능을 제공하는 것보다는 별도 서비스로 식별자 생성 기능을 분리 해야함.
  - 식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야한다.

  ```java
	public class ProductIdService {
		public ProductId nextId() {
			//정해진 규칙으로 식별자 생성
		}
	}
  ```
  - 이 도메인 서비스를 이용해서 응용서비스에서 식별자를 구하고 엔티티를 생성한다. (p.140~ 141)
  - 식별자 생성 규칙을 구현하기에 적합한 또 다른 장소는 리포지터리이다. 리포지터리 인터페이스에 식별자를 생성하는 메서드를 추가하고 리포지터리 구현 클래스에서 알맞게 구현하면 된다.
- DB를 이용한 일련변호 생성
  - 식별자 생성으로 DB의 자동 증가 컬럼을 사용할 경우 JPA의 식별자 매핑에서 @GeneratedValue를 사용한다. JPA는 저장 시점에 생성한 식별자를 @Id로 매핑한 프로퍼티/필드에 할당한다.

#### 참조
- > [최범균,『DDD Start!』, 지앤선(2016)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=84000742)
