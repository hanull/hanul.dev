---
title: 리포지터리와 모델구현
date: 2020-01-22 18:01:57
category: domaindrivendesign
draft: false
---

## JPA를 이용한 리포지터리 구현
데이터 보관소로 RDBMS를 사용할 때 객체 기반의 도메인 모델과 관계형 데이터 모델 간의 매핑을 처리하는 기술로 `ORM` 만한 것이 없다.

### 모듈 위치
리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.
> 리포지터리 구현 클래스를 인터페이스와 같은 패키지에 위치시키는 것은 좋은 방법이 아니다. => 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 *의존을 낮춰야 한다.*

### 리포지터리 기본 기능 구현
- 아이디로 애그리거트 조회하기
- 애그리거트 저장하기

```java
public interface OrderRepository {
    public Order findById(OrderNo no);
    public void save(Order order);
}
```
- 인터페이스는 애그리거트 루트를 기준으로 작성한다.
- 애그리거트를 조회 기능의 이름을 지을 때는 보통 `findBy 프로피터값`의 형식을 사용한다.
  - e.g. findById, findByOrdererId
  - findById()는 해당 애그리거트가 존재하지 않으면 null을 리턴한다. null을 사용하고 싶지 않다면 `Optional`을 이용해서 값을 리턴해도 된다.
- save() 메서드는 전달받은 애그리거트를 저장한다. 이를 구현한 클래스는 `JPA의 EntityManager`를 이용해서 기능 구현을 한다.
  - @PersistenceContext
  > 엔티티를 저장( persist() ) , 조회( find() 또는 JPQL , QueryDSL )하면 엔티티 매니저는 그 엔티티를 영속성 컨테스트에 보관하고 관리한다.
- 애그리거트를 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요 없다. JPA를 사용하면 트랙잭션 범위에서 변경한 데이터를 자동으로 DB에 반경해준다.
- 삭제 기능을 구현하는 메서드는 삭제할 애그리거트 객체를 파라미터로 전달받는다.
  - soft delete를 사용하는 편이 좋다. 

## 매핑 구현

## 애그리거트 로딩 전략

## 애그리거트의 영속성 전파

## 식별자 생성 기능



#### 참조
- > [최범균,『DDD Start!』, 지앤선(2016)](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=84000742)